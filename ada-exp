import java.util.Scanner;
public class PrimsAlgorithm1 {

 static final int INF = 9999;
 static final int MAX = 20;
 static int[][] G = new int[MAX][MAX];
 static int[][] spanning = new int[MAX][MAX];
 static int n;

 public static void main(String[] args) {
  Scanner scanner = new Scanner(System.in);
  System.out.print("Enter the number of vertices: ");
  n = scanner.nextInt();
  System.out.println("\nEnter the adjacency matrix:");
  for (int i = 0; i < n; i++) {
   for (int j = 0; j < n; j++) {
    G[i][j] = scanner.nextInt();
   }
  }
  int totalCost = prims();
  System.out.println("\nSpanning tree matrix:");
  for (int i = 0; i < n; i++) {
   for (int j = 0; j < n; j++) {
    System.out.print(spanning[i][j] + "\t");
   }
   System.out.println();
  }
  System.out.println("\nTotal cost of the spanning tree = " + totalCost);
 }

 static int prims() {
  int[][] cost = new int[MAX][MAX];
  int[] distance = new int[MAX];
  int[] from = new int[MAX];
  int[] visited = new int[MAX];
  int minCost = 0;

  for (int i = 0; i < n; i++) {
   for (int j = 0; j < n; j++) {
    if (G[i][j] == 0) {
     cost[i][j] = INF;
    } else {
     cost[i][j] = G[i][j];
    }
    spanning[i][j] = 0;
   }
  }

  distance[0] = 0;
  visited[0] = 1;
  for (int i = 1; i < n; i++) {
   distance[i] = cost[0][i];
   from[i] = 0;
   visited[i] = 0;
  }

  int noOfEdges = n - 1;
  while (noOfEdges > 0) {
   int minDistance = INF, v = -1;
   for (int i = 1; i < n; i++) {
    if (visited[i] == 0 && distance[i] < minDistance) {
     v = i;
     minDistance = distance[i];
    }
   }
   int u = from[v];
   spanning[u][v] = distance[v];
   spanning[v][u] = distance[v];
   noOfEdges--;
   visited[v] = 1;
   for (int i = 1; i < n; i++) {
    if (visited[i] == 0 && cost[i][v] < distance[i]) {
     distance[i] = cost[i][v];
     from[i] = v;
    }
   }
   minCost += cost[u][v];
  }
  return minCost;
 }
}


5b}
public class DijkstraAlgorithm {

    public void dijkstraAlgorithm(int[][] graph, int source) {
        int nodes = graph.length;
        boolean[] visited_vertex = new boolean[nodes];
        int[] dist = new int[nodes];
        for (int i = 0; i < nodes; i++) {
            visited_vertex[i] = false;
            dist[i] = Integer.MAX_VALUE;
        }

        dist[source] = 0;
        for (int i = 0; i < nodes; i++) {
            int u = find_min_distance(dist, visited_vertex);
            visited_vertex[u] = true;

            for (int v = 0; v < nodes; v++) {
                if (!visited_vertex[v] && graph[u][v] != 0 && (dist[u] + graph[u][v] < dist[v])) {
                    dist[v] = dist[u] + graph[u][v];
                }
            }
        }
        for (int i = 0; i < dist.length; i++) {
            System.out.println(String.format("Distance from Vertex %s toVertex %s is %s", source, i, dist[i]));
        }
    }

    private static int find_min_distance(int[] dist, boolean[] visited_vertex) {
        int minimum_distance = Integer.MAX_VALUE;
        int minimum_distance_vertex = -1;
        for (int i = 0; i < dist.length; i++) {
            if (!visited_vertex[i] && dist[i] < minimum_distance) {
                minimum_distance = dist[i];
                minimum_distance_vertex = i;
            }
        }
        return minimum_distance_vertex;
    }

    public static void main(String[] args) {
        int graph[][] = new int[][] {
            { 0, 1, 1, 2, 0, 0, 0 },
            { 0, 0, 2, 0, 0, 3, 0 },
            { 1, 2, 0, 1, 3, 0, 0 },
            { 2, 0, 1, 0, 2, 0, 1 },
            { 0, 0, 3, 0, 0, 2, 0 },
            { 0, 3, 0, 0, 2, 0, 1 },
            { 0, 2, 0, 1, 0, 1, 0 }
        };

        DijkstraAlgorithm Test = new DijkstraAlgorithm();

        Test.dijkstraAlgorithm(graph, 0);
    }
}


6}
import java.lang.*;
public class AllPairShortestPath {
    final static int INF = 99999, V = 4;
    void floydWarshall(int dist[][]) {
        int i, j, k;
        for (k = 0; k < V; k++) {
            for (i = 0; i < V; i++) {
                for (j = 0; j < V; j++) {
                    if (dist[i][k] + dist[k][j] < dist[i][j])
                        dist[i][j] = dist[i][k] + dist[k][j];
                }
            }
        }
        printSolution(dist);
    }
    void printSolution(int dist[][]) {
        System.out.println("The following matrix shows the shortest distances between every pair of vertices");
        for (int i = 0; i < V; ++i) {
            for (int j = 0; j < V; ++j) {
                if (dist[i][j] == INF)
                    System.out.print("INF ");
                else
                    System.out.print(dist[i][j] + " ");
            }
            System.out.println();
        }
    }
    public static void main(String[] args) {
        int graph[][] = {
            { 0, 5, INF, 10 },
            { INF, 0, 3, INF },
            { INF, INF, 0, 1 },
            { INF, INF, INF, 0 }
        };
        AllPairShortestPath a = new AllPairShortestPath();
        a.floydWarshall(graph);
    }
}


7}
public class HamiltonianCycle {

    final int V = 5;
    int path[];

    boolean isSafe(int v, int graph[][], int path[], int pos) {
        if (graph[path[pos - 1]][v] == 0)
            return false;
        for (int i = 0; i < pos; i++)
            if (path[i] == v)
                return false;
        return true;
    }

    boolean hamCycleUtil(int graph[][], int path[], int pos) {
        if (pos == V) {
            if (graph[path[pos - 1]][path[0]] == 1)
                return true;
            else
                return false;
        }
        for (int v = 1; v < V; v++) {
            if (isSafe(v, graph, path, pos)) {
                path[pos] = v;
                if (hamCycleUtil(graph, path, pos + 1) == true)
                    return true;
                path[pos] = -1;
            }
        }
        return false;
    }

    int hamCycle(int graph[][]) {
        path = new int[V];
        for (int i = 0; i < V; i++)
            path[i] = -1;
        path[0] = 0;
        if (hamCycleUtil(graph, path, 1) == false) {
            System.out.println("\nSolution does not exist");
            return 0;
        }
        printSolution(path);
        return 1;
    }

    void printSolution(int path[]) {
        System.out.println("Solution Exists: Following is one Hamiltonian Cycle");
        for (int i = 0; i < V; i++)
            System.out.print(" " + path[i] + " ");
        System.out.println(" " + path[0] + " ");
    }

    public static void main(String args[]) {
        HamiltonianCycle hamiltonian = new HamiltonianCycle();

        int graph1[][] = {
            {0, 1, 0, 1, 0},
            {1, 0, 1, 1, 1},
            {0, 1, 0, 0, 1},
            {1, 1, 0, 0, 1},
            {0, 1, 1, 1, 0},
        };
        hamiltonian.hamCycle(graph1);

        System.out.println("For Graph 2:");
        int graph2[][] = {
            {0, 1, 0, 1, 0},
            {1, 0, 1, 1, 1},
            {0, 1, 0, 0, 1},
            {1, 1, 0, 0, 0},
            {0, 1, 1, 0, 0},
        };
        hamiltonian.hamCycle(graph2);
    }
}


8}
public class LCMCalculator {
    private static int gcd(int a, int b) {
        if (b == 0)
            return a;
        return gcd(b, a % b);
    }

    private static int lcm(int a, int b) {
        return (a * b) / gcd(a, b);
    }

    public static int lcmArray(int[] arr) {
        int result = arr[0];
        for (int i = 1; i < arr.length; i++) {
            result = lcm(result, arr[i]);
        }
        return result;
    }

    public static void main(String[] args) {
        int[] numbers = {12, 15, 20, 25};
        int result = lcmArray(numbers);
        System.out.println("LCM of the array is: " + result);
    }
}
